
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "generated/autoexamples/example_2D_trajectories.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_generated_autoexamples_example_2D_trajectories.py>`
        to download the full example code. or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_generated_autoexamples_example_2D_trajectories.py:


===============
2D Trajectories
===============

A collection of 2D non-Cartesian trajectories with analytical definitions.

.. GENERATED FROM PYTHON SOURCE LINES 11-16

Hereafter we detail and illustrate the different arguments used in the
parameterization of 2D non-Cartesian trajectories. Since most arguments
are redundant across the different patterns, some of the documentation
will refer to previous patterns for explanation.


.. GENERATED FROM PYTHON SOURCE LINES 16-27

.. code-block:: Python


    # External
    import matplotlib.pyplot as plt
    import numpy as np
    from utils import show_argument, show_trajectory

    # Internal
    import mrinufft as mn
    import mrinufft.trajectories.maths as mntm
    from mrinufft import display_2D_trajectory








.. GENERATED FROM PYTHON SOURCE LINES 28-31

Script options
==============
These options are used in the examples below as default values for all trajectories.

.. GENERATED FROM PYTHON SOURCE LINES 31-45

.. code-block:: Python


    # Trajectory parameters
    Nc = 24  # Number of shots
    Ns = 256  # Number of samples per shot
    in_out = True  # Choose between in-out or center-out trajectories
    tilt = "uniform"  # Choose the angular distance between shots
    nb_repetitions = 6  # Number of strips when relevant

    # Display parameters
    figure_size = 6  # Figure size for trajectory plots
    subfigure_size = 3  # Figure size for subplots
    one_shot = True  # Highlight one shot in particular









.. GENERATED FROM PYTHON SOURCE LINES 46-63

Circular patterns
==================

Radial
------

The most basic non-Cartesian trajectory composed of straight lines with
no customization arguments besides the common ones.

Arguments:

- ``Nc (int)``: number of individual shots
- ``Ns (int)``: number of samples per shot
- ``tilt (str, float)``: angle between each consecutive shot (in radians) ``(default "uniform")``
- ``in_out (bool)``: define whether the shots should travel toward the center
  then outside (in-out) or not (center-out). ``(default False)``


.. GENERATED FROM PYTHON SOURCE LINES 63-68

.. code-block:: Python


    trajectory = mn.initialize_2D_radial(Nc, Ns, tilt=tilt, in_out=in_out)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_001.png
   :alt: example 2D trajectories
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 69-75

``Nc (int)``
~~~~~~~~~~~~

The number of individual shots, here straight lines, used to cover the
k-space. More shots means better coverage but also longer acquisitions.


.. GENERATED FROM PYTHON SOURCE LINES 75-81

.. code-block:: Python


    arguments = [8, 16, 32, 64]
    function = lambda x: mn.initialize_2D_radial(x, Ns, tilt=tilt, in_out=in_out)
    show_argument(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_002.png
   :alt: 8, 16, 32, 64
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 82-89

``Ns (int)``
~~~~~~~~~~~~

The number of samples per shot. More samples means the lines are split
into more smaller segments, and therefore either the acquisition window
is lengthened or the sampling rate is increased.


.. GENERATED FROM PYTHON SOURCE LINES 89-95

.. code-block:: Python


    arguments = [8, 16, 32, 64]
    function = lambda x: mn.initialize_2D_radial(Nc, x, tilt=tilt, in_out=in_out)
    show_argument(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_003.png
   :alt: 8, 16, 32, 64
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 96-105

``tilt (str, float)``
~~~~~~~~~~~~~~~~~~~~~

The angle between each consecutive shots, either in radians or as a
string defining some default mods such as “uniform” for
:math:`2 \pi / N_c`, or “golden” and “mri golden” for the different
common definitions of golden angles. The angle is automatically adapted
when the ``in_out`` argument is switched to keep the same behavior.


.. GENERATED FROM PYTHON SOURCE LINES 105-111

.. code-block:: Python


    arguments = ["uniform", "golden", "mri-golden", np.pi / 17]
    function = lambda x: mn.initialize_2D_radial(Nc, Ns, tilt=x, in_out=in_out)
    show_argument(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_004.png
   :alt: uniform, golden, mri-golden, 0.18479956785822313
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 112-128

``in_out (bool)``
~~~~~~~~~~~~~~~~~

It allows to switch between different ways to define how the shot should
travel through the k-space:

- in-out: starting from the outer regions, then passing through the center
  then going back to outer regions, often on the opposite side (radial, cones)
- center-out or center-center: when ``in_out=False`` the trajectory will start
  at the center, but depending on the specific trajectory formula the path might
  end up in the outer regions (radial, spiral, cones, etc) or back to the center (rosette,
  lissajous).

Note that the behavior of ``tilt`` is automatically adapted to the changes to avoid having
to update it too when switching ``in_out``.


.. GENERATED FROM PYTHON SOURCE LINES 128-134

.. code-block:: Python


    arguments = [True, False]
    function = lambda x: mn.initialize_2D_radial(Nc, Ns, tilt=tilt, in_out=x)
    show_argument(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_005.png
   :alt: True, False
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_005.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 135-156

Spiral
------

A generalized function that generates algebraic spirals defined
through the :math:`r = a \theta^n` equation, with :math:`r` the radius,
:math:`\theta` the polar angle and :math:`n` the spiral power.
Common algebraic spirals include Archimedes, Fermat and Galilean spirals.

Arguments:

- ``Nc (int)``: number of individual shots. See radial
- ``Ns (int)``: number of samples per shot. See radial
- ``tilt (str, float)``: angle between each consecutive shot (in radians).
  ``(default "uniform")``. See radial
- ``in_out (bool)``: define whether the shots should travel toward the center
  then outside (in-out) or not (center-out). ``(default False)``. See radial
- ``nb_revolutions (float)``: number of revolutions performed from the
  center. ``(default 1)``
- ``spiral (str, float)``: type of spiral defined through the above-mentionned equation.
  ``(default "archimedes")``


.. GENERATED FROM PYTHON SOURCE LINES 156-161

.. code-block:: Python


    trajectory = mn.initialize_2D_spiral(Nc, Ns, tilt=tilt, in_out=in_out)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_006.png
   :alt: example 2D trajectories
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_006.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 162-168

``nb_revolutions (float)``
~~~~~~~~~~~~~~~~~~~~~~~~~~

The number of revolutions performed from the center (i.e. performed
twice for in-out trajectories).


.. GENERATED FROM PYTHON SOURCE LINES 168-176

.. code-block:: Python


    arguments = [1 / 8, 1 / 2, 1, 3]
    function = lambda x: mn.initialize_2D_spiral(
        Nc, Ns, tilt=tilt, nb_revolutions=x, in_out=in_out
    )
    show_argument(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_007.png
   :alt: 0.125, 0.5, 1, 3
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_007.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 177-194

``spiral (str, float)``
~~~~~~~~~~~~~~~~~~~~~~~

The algebraic spiral power defined through :math:`n` in the
:math:`r = a \theta^n` equality, with :math:`r` the radius and
:math:`\theta` the polar angle. It defines the gradient behavior,
and therefore the distance between consecutive points and the shape
of the spiral. It does not affect the number of revolutions, but
rather the curve length and point distribution. Spirals with small
:math:`n` (close to 0) tend to have radial behaviors
around the center, and dedicate more points towards curved edges.

``"archimedes"`` (1), ``"fermat"`` (0.5) and ``"galilean"`` (2) are available
as string options for convenience. Algebraic spirals with negative powers,
such as hyperbolic or lithuus spirals, are not considered relevant because
of their asymptotic behavior around the center.


.. GENERATED FROM PYTHON SOURCE LINES 194-200

.. code-block:: Python


    arguments = ["galilean", "archimedes", "fermat", 1 / 4]
    function = lambda x: mn.initialize_2D_spiral(Nc, Ns, tilt=tilt, spiral=x, in_out=in_out)
    show_argument(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_008.png
   :alt: galilean, archimedes, fermat, 0.25
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_008.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 201-217

``patch_center (float)``
~~~~~~~~~~~~~~~~~~~~~~~~

A slew rate anomaly is present at the center of algebraic spirals
when their power is inferior to 1 (e.g. Fermat's) and parameterized
through their angles in the above equation.

To fix this problem, points at the center are re-arranged along
the spiral until the gradients are monotically increasing from
the center to the edges. This correction can be deactivated,
but it is generally preferred to keep it.

The spiral path is not changed, but the density can be altered
over the first few samples. However the difference is extremely
subtle, as shown below.


.. GENERATED FROM PYTHON SOURCE LINES 217-227

.. code-block:: Python


    arguments = [False, True]
    function = lambda x: mn.initialize_2D_spiral(
        Nc,
        Ns,
        patch_center=x,
    )
    show_argument(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_009.png
   :alt: False, True
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_009.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 228-246

Fibonacci spiral
----------------

A non-algebraic spiral trajectory based on the Fibonacci sequence,
reproducing the proposition from [CA99]_ in order to generate
a uniform distribution with center-out shots.

The number of shots is required to belong to the Fibonacci
sequence for the trajectory definition to be relevant.

Arguments:

- ``Nc (int)``: number of individual shots. See radial
- ``Ns (int)``: number of samples per shot. See radial
- ``spiral_reduction (float)``: factor used to reduce the automatic spiral length. ``(default 1)``
- ``patch_center (bool)``: whether the spiral anomaly at the center should be patched.
  ``(default True)``


.. GENERATED FROM PYTHON SOURCE LINES 246-252

.. code-block:: Python


    Nc_fibonacci = mntm.get_closest_fibonacci_number(Nc)
    trajectory = mn.initialize_2D_fibonacci_spiral(Nc_fibonacci, Ns)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_010.png
   :alt: example 2D trajectories
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_010.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 253-263

``spiral_reduction (float)``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Factor used to reduce the automatic spiral length. In opposition to
``initialize_2D_spiral``, the number of spiral revolutions here
is automatically determined from ``Ns`` and ``Nc`` to match a uniform
density over the k-space sphere. It can lead to unrealistically
strong gradients, and therefore we provide this factor to reduce the
spiral length, which makes k-space denser along the shorter shots.


.. GENERATED FROM PYTHON SOURCE LINES 263-273

.. code-block:: Python


    arguments = [0.5, 1, 2, 3]
    function = lambda x: mn.initialize_2D_fibonacci_spiral(
        Nc_fibonacci,
        Ns,
        spiral_reduction=x,
    )
    show_argument(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_011.png
   :alt: 0.5, 1, 2, 3
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_011.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 274-289

``patch_center (float)``
~~~~~~~~~~~~~~~~~~~~~~~~

Similarly to algebraic spirals from ``initialize_2D_spiral``,
the trajectory definition creates small anomalies at the center
that makes slew rate requirements needlessly high.

It is here related to the uniform density that requires central
samples to be more strongly spaced than anywhere else because
most shots start close to the center.

The spiral path can be altered over the first few samples,
but generally the difference is extremely subtle, as shown
below.


.. GENERATED FROM PYTHON SOURCE LINES 289-299

.. code-block:: Python


    arguments = [False, True]
    function = lambda x: mn.initialize_2D_fibonacci_spiral(
        Nc_fibonacci,
        Ns,
        patch_center=x,
    )
    show_argument(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_012.png
   :alt: False, True
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_012.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 300-319

Cones
-----

A radial-like trajectory zigzaging within cones over the k-space to
offer a better coverage than radial with more customization parameters.

Arguments:

- ``Nc (int)``: number of individual shots. See radial
- ``Ns (int)``: number of samples per shot. See radial
- ``tilt (str, float)``: angle between each consecutive shot (in radians).
  ``(default "uniform")``. See radial
- ``in_out (bool)``: define whether the shots should travel toward the center
  then outside (in-out) or not (center-out). ``(default False)``. See radial
- ``nb_zigzags (float)``: number of sinusoidal patterns over a center-out shot.
  ``(default 5)``
- ``width (float)``: cone width factor, normalized to cover the k-space by default.
  ``(default 1)``


.. GENERATED FROM PYTHON SOURCE LINES 319-324

.. code-block:: Python


    trajectory = mn.initialize_2D_cones(Nc, Ns, tilt=tilt, in_out=in_out)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_013.png
   :alt: example 2D trajectories
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_013.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 325-331

``nb_zigzags (float)``
~~~~~~~~~~~~~~~~~~~~~~

The number of “zigzags”, or sinusoidal patterns present over a center-out shot
(doubled overall for in-out trajectories)


.. GENERATED FROM PYTHON SOURCE LINES 331-339

.. code-block:: Python


    arguments = [0.5, 2, 5, 10]
    function = lambda x: mn.initialize_2D_cones(
        Nc, Ns, tilt=tilt, in_out=in_out, nb_zigzags=x
    )
    show_argument(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_014.png
   :alt: 0.5, 2, 5, 10
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_014.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 340-348

``width (float)``
~~~~~~~~~~~~~~~~~

The cone width normalized such that ``width = 1`` corresponds to
non-overlapping cones covering the whole k-space circle, and
therefore ``width > 1`` creates overlap between cone regions and
``width < 1`` tends to more radial patterns.


.. GENERATED FROM PYTHON SOURCE LINES 348-354

.. code-block:: Python


    arguments = [0.2, 1, 2, 3]
    function = lambda x: mn.initialize_2D_cones(Nc, Ns, tilt=tilt, in_out=in_out, width=x)
    show_argument(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_015.png
   :alt: 0.2, 1, 2, 3
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_015.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 355-374

Sinusoide
---------

Another radial-like trajectory zigzaging similarly to cones, but over a
whole band rather than cones reduced towards the center.

Arguments:

- ``Nc (int)``: number of individual shots. See radial
- ``Ns (int)``: number of samples per shot. See radial
- ``tilt (str, float)``: angle between each consecutive shot (in radians).
- ``(default "uniform")``. See radial
- ``in_out (bool)``: define whether the shots should travel toward the center
  then outside (in-out) or not (center-out). ``(default False)``. See radial
- ``nb_zigzags (float)``: number of sinusoidal patterns over a center-out shot.
  ``(default 5)``. See cones
- ``width (float)``: shot width factor, normalized to cover the k-space by default.
  ``(default 1)``. See cones


.. GENERATED FROM PYTHON SOURCE LINES 374-379

.. code-block:: Python


    trajectory = mn.initialize_2D_sinusoide(Nc, Ns, tilt=tilt, in_out=in_out)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_016.png
   :alt: example 2D trajectories
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_016.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 380-400

PROPELLER
---------

The PROPELLER trajectory is generally used along a specific
reconstruction pipeline described in [Pip99]_ to correct for
motion artifacts.

The acronym PROPELLER stands for Periodically Rotated
Overlapping ParallEL Lines with Enhanced Reconstruction,
and the method is also commonly known under other aliases
depending on the vendor, with some variations: BLADE,
MulitVane, RADAR, JET.

Arguments:

- ``Nc (int)``: number of individual shots. See radial
- ``Ns (int)``: number of samples per shot. See radial
- ``nb_strips (int)``: number of strips covering the k-space.
  ``(default "uniform")``. See radial


.. GENERATED FROM PYTHON SOURCE LINES 400-405

.. code-block:: Python


    trajectory = mn.initialize_2D_propeller(Nc, Ns, nb_strips=nb_repetitions)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_017.png
   :alt: example 2D trajectories
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_017.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 406-413

``nb_strips (int)``
~~~~~~~~~~~~~~~~~~~

The number of individual strips dividing the k-space circle. It must divide
the number of shots ``Nc``, and it is recommended to choose it such that the
ratio is even to cover the center.


.. GENERATED FROM PYTHON SOURCE LINES 413-419

.. code-block:: Python


    arguments = [2, 3, 4, 6]
    function = lambda x: mn.initialize_2D_propeller(Nc, Ns, nb_strips=x)
    show_argument(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_018.png
   :alt: 2, 3, 4, 6
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_018.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 420-436

Rings
-------

A pattern composed of concentric circles like a target, with each
ring composed of one or more shots . This trajectory was initially
proposed by Wu, Hochong H., Jin Hyung Lee, and Dwight G. Nishimura.
"MRI using a concentric rings trajectory." Magnetic Resonance in Medicine
59, no. 1 (2008): 102-112.

Arguments:

- ``Nc (int)``: number of individual shots. See radial
- ``Ns (int)``: number of samples per shot. See radial
- ``nb_rings (int)``: number of rings used to partition the k-space.
  It should be lower than or equal to ``Nc``.


.. GENERATED FROM PYTHON SOURCE LINES 436-441

.. code-block:: Python


    trajectory = mn.initialize_2D_rings(Nc, Ns, nb_rings=Nc)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_019.png
   :alt: example 2D trajectories
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_019.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 442-450

``nb_rings (int)``
~~~~~~~~~~~~~~~~~~

The number of rings used to partition the k-space. It should always be lower
than or equal to :math:`N_c` as the implementation does not permit shots to cover
several rings. Note that to fully sample a k-space circle, it should be
set around :math:`FOV / (2 * resolution)`.


.. GENERATED FROM PYTHON SOURCE LINES 450-455

.. code-block:: Python


    arguments = [Nc, int(2 * Nc / 3), int(Nc / 3)]
    function = lambda x: mn.initialize_2D_rings(Nc=x, Ns=Ns, nb_rings=x)
    show_argument(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)




.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_020.png
   :alt: 24, 16, 8
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_020.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 456-460

This implementation allows using more shots than rings, and it will automatically
attribute the additional shots to the longest rings to reduce the top gradient
amplitude and slew rate.


.. GENERATED FROM PYTHON SOURCE LINES 461-467

.. code-block:: Python


    arguments = [Nc, int(4 * Nc / 3), 2 * Nc]
    function = lambda x: mn.initialize_2D_rings(Nc=x, Ns=Ns, nb_rings=Nc)
    show_argument(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_021.png
   :alt: 24, 32, 48
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_021.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 468-483

Rosette
-------

A repeating pattern composed of a single long curve going through the
center multiple times and split into multiple shots.

Arguments:

- ``Nc (int)``: number of individual shots. See radial
- ``Ns (int)``: number of samples per shot. See radial
- ``in_out (bool)``: define whether the shots should travel toward the center
  then outside (in-out) or not (center-out). ``(default False)``. See radial
- ``coprime_index (int)``: the index of the coprime factor used
  to define the shot curvature. ``(default 0)``


.. GENERATED FROM PYTHON SOURCE LINES 483-488

.. code-block:: Python


    trajectory = mn.initialize_2D_rosette(Nc, Ns, in_out=in_out)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_022.png
   :alt: example 2D trajectories
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_022.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 489-501

``coprime_index (int)``
~~~~~~~~~~~~~~~~~~~~~~~

The index used to select a compatible coprime factor, parameterized such
that trajectories keep :math:`N_c` petals while increasing their width,
i.e. increasing the curvature of the shots. This argument is quite
complex with regard to the original formula in order to remain easily
interpretable, user-friendly and optimal for MR use cases. For more
details, please consult this `Wikipedia page`_.

.. _Wikipedia page: https://en.wikipedia.org/wiki/Rose\_(mathematics)#Roses_with_rational_number_values_for_k.


.. GENERATED FROM PYTHON SOURCE LINES 501-507

.. code-block:: Python


    arguments = [0, 1, 5, 10]
    function = lambda x: mn.initialize_2D_rosette(Nc, Ns, in_out=in_out, coprime_index=x)
    show_argument(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_023.png
   :alt: 0, 1, 5, 10
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_023.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 508-526

Polar Lissajous
---------------

A polar version of the Lissajous curve, repeating pattern composed of a
single long curve going through the center multiple times and split into
multiple shots.

Arguments:

- ``Nc (int)``: number of individual shots. See radial
- ``Ns (int)``: number of samples per shot. See radial
- ``in_out (bool)``: define whether the shots should travel toward the center
  then outside (in-out) or not (center-out). ``(default False)``. See radial
- ``coprime_index (int)``: the index of the coprime factor used # to define
  the shot curvature. ``(default 0)``
- ``nb_segments (int)``: number of indepedent Lissajous curves covering
  different segments of the k-space. ``(default 1)``


.. GENERATED FROM PYTHON SOURCE LINES 526-531

.. code-block:: Python


    trajectory = mn.initialize_2D_polar_lissajous(Nc, Ns, in_out=in_out)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_024.png
   :alt: example 2D trajectories
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_024.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 532-539

``coprime_index (int)``
~~~~~~~~~~~~~~~~~~~~~~~

The index used to select a compatible coprime factor, and impacting the
shot curvature. For now, it is less trivial to select than for rosette
but it will be updated in the future.


.. GENERATED FROM PYTHON SOURCE LINES 539-547

.. code-block:: Python


    arguments = [0, 3, 12, 15]
    function = lambda x: mn.initialize_2D_polar_lissajous(
        Nc, Ns, in_out=in_out, coprime_index=x
    )
    show_argument(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_025.png
   :alt: 0, 3, 12, 15
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_025.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 548-562

``nb_segments (int)``
~~~~~~~~~~~~~~~~~~~~~

The number of Lissajous curves and segmented regions of the k-space. The
polar Lissajous curve natively puts emphasis on the center and along the
:math:`k_y` axis, but can be parameterized to rather emphasize
``nb_segments`` axes by reducing the coverage and duplicating a shorter
curve.

In the example below, ``nb_segments = 2`` emphasizes the diagonals as
two Lissajous curves were created with each of them only covering two
opposing quarters of the k-space. It implies that ``nb_segments`` should
be a divider of ``Nc``.


.. GENERATED FROM PYTHON SOURCE LINES 562-570

.. code-block:: Python


    arguments = [1, 2, 3, 4, 6, 8, 12]
    function = lambda x: mn.initialize_2D_polar_lissajous(
        Nc, Ns, in_out=in_out, nb_segments=x
    )
    show_argument(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_026.png
   :alt: 1, 2, 3, 4, 6, 8, 12
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_026.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 571-584

Comments
~~~~~~~~

This specific curve has never been used in MRI to the best of our
knowledge, and was inspired by the `MathCurve page`_. It is heavily
related to the rosette trajectory but parameterized in a much more
complex way, as shown below when varying both ``coprime_index`` and
``nb_segments``. It is not necessarily fit for MR applications, but was
added out of personal interest in an effort to explore potentially
unexploited geometries.

.. _MathCurve page: https://mathcurve.com/courbes2d.gb/lissajous/lissajous.shtml


.. GENERATED FROM PYTHON SOURCE LINES 584-596

.. code-block:: Python


    for io in [True, False]:
        for cpi in [0, 6]:
            arguments = [1, 2, 4, 12]
            function = lambda x: mn.initialize_2D_polar_lissajous(
                Nc, Ns, in_out=io, coprime_index=cpi, nb_segments=x
            )
            show_argument(
                function, arguments, one_shot=one_shot, subfig_size=subfigure_size
            )





.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_027.png
         :alt: 1, 2, 4, 12
         :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_027.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_028.png
         :alt: 1, 2, 4, 12
         :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_028.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_029.png
         :alt: 1, 2, 4, 12
         :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_029.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_030.png
         :alt: 1, 2, 4, 12
         :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_030.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 597-614

Non-circular patterns
=====================

Waves
---------

An extension of the Cartesian line-by-line pattern that simply adds sinusoidal
variations along the :math:`k_y` axis.

Arguments:

- ``Nc (int)``: number of individual shots. See radial
- ``Ns (int)``: number of samples per shot. See radial
- ``nb_zigzags (float)``: number of sinusoide patterns along a line. ``(default 5)``
- ``width (float)``: line width normalized such that a width of 1 corresponds
  to covering the full band without overlapping other bands. ``(default 1)``


.. GENERATED FROM PYTHON SOURCE LINES 614-619

.. code-block:: Python


    trajectory = mn.initialize_2D_waves(Nc, Ns, nb_zigzags=5)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_031.png
   :alt: example 2D trajectories
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_031.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 620-625

``nb_zigzags (float)``
~~~~~~~~~~~~~~~~~~~~~~

The number of sinusoidal patterns along a line, similar to cones and sinusoidal trajectories.


.. GENERATED FROM PYTHON SOURCE LINES 625-631

.. code-block:: Python


    arguments = [1, 2.5, 5, 10]
    function = lambda x: mn.initialize_2D_waves(Nc, Ns, nb_zigzags=x)
    show_argument(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_032.png
   :alt: 1, 2.5, 5, 10
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_032.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 632-644

``width (float)``
~~~~~~~~~~~~~~~~~

The line width normalized such that ``width = 1`` corresponds to
non-overlapping lines covering (almost) uniformly the whole k-space, and
therefore ``width > 1`` creates overlap between regions and
``width < 1`` tends to Cartesian patterns.
Also notes that increasing width squeezes the lines together
such that shots at the top and bottom borders don't spread ouf of the k-space,
resulting in non-covered areas with large widths. This behavior might be subject to
changes in future versions.


.. GENERATED FROM PYTHON SOURCE LINES 644-650

.. code-block:: Python


    arguments = [0, 1, 1.5, 3]
    function = lambda x: mn.initialize_2D_waves(Nc, Ns, width=x)
    show_argument(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_033.png
   :alt: 0, 1, 1.5, 3
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_033.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 651-667

Lissajous
---------

The classic Lissajous patterns composed of a long single curve split into shots
with different curve profiles and covering the whole k-space square.
This pattern tends to be more dense on the edges, as opposed to most others.
Note that the original pattern is much more complex but has been simplified
to match MR purposes, with a balanced distribution and minimal overlapping.

Arguments:

- ``Nc (int)``: number of individual shots
- ``Ns (int)``: number of samples per shot
- ``density (float)``: controls the pseudo-grid density and shot curvatures.
  ``(default "1")``


.. GENERATED FROM PYTHON SOURCE LINES 667-672

.. code-block:: Python


    trajectory = mn.initialize_2D_lissajous(Nc, Ns, density=1)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_034.png
   :alt: example 2D trajectories
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_034.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 673-679

``density (float)``
~~~~~~~~~~~~~~~~~~~~~~

It relates to both the curve length and curvature, normalized such that
``density = 1`` corresponds to pseudo-diagonal curves for any given :math:`N_c`.


.. GENERATED FROM PYTHON SOURCE LINES 679-685

.. code-block:: Python


    arguments = [1, 1.5, 2, 3]
    function = lambda x: mn.initialize_2D_lissajous(Nc, Ns, density=x)
    show_argument(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_035.png
   :alt: 1, 1.5, 2, 3
   :srcset: /generated/autoexamples/images/sphx_glr_example_2D_trajectories_035.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 686-692

References
==========

.. [Pip99] Pipe, James G. "Motion correction with PROPELLER MRI:
   application to head motion and free‐breathing cardiac imaging."
   Magnetic Resonance in Medicine 42, no. 5 (1999): 963-969.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 28.947 seconds)


.. _sphx_glr_download_generated_autoexamples_example_2D_trajectories.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: binder-badge

      .. image:: images/binder_badge_logo.svg
        :target: https://mybinder.org/v2/gh/mind-inria/mri-nufft/gh-pages?urlpath=lab/tree/examples/generated/autoexamples/example_2D_trajectories.ipynb
        :alt: Launch binder
        :width: 150 px

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: example_2D_trajectories.ipynb <example_2D_trajectories.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: example_2D_trajectories.py <example_2D_trajectories.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: example_2D_trajectories.zip <example_2D_trajectories.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
