
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "generated/autoexamples/GPU/example_density.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_generated_autoexamples_GPU_example_density.py>`
        to download the full example code. or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_generated_autoexamples_GPU_example_density.py:


=============================
Density Compensation Routines
=============================

Examples of differents density compensation methods.

Density compensation depends on the sampling trajectory,and is apply before the
adjoint operation to act as preconditioner, and should make the lipschitz constant
of the operator roughly equal to 1.

.. GENERATED FROM PYTHON SOURCE LINES 15-19

.. colab-link::
   :needs_gpu: 1

   !pip install mri-nufft[gpunufft] finufft

.. GENERATED FROM PYTHON SOURCE LINES 21-23

Imports
-------

.. GENERATED FROM PYTHON SOURCE LINES 23-31

.. code-block:: Python

    import brainweb_dl as bwdl
    import matplotlib.pyplot as plt
    import numpy as np

    from mrinufft import get_density, get_operator
    from mrinufft.trajectories import initialize_2D_radial
    from mrinufft.trajectories.display import display_2D_trajectory








.. GENERATED FROM PYTHON SOURCE LINES 32-34

Create sample data
------------------

.. GENERATED FROM PYTHON SOURCE LINES 34-50

.. code-block:: Python


    mri_2D = np.flipud(bwdl.get_mri(4, "T1")[80, ...]).astype(np.float32)

    print(mri_2D.shape)

    traj = initialize_2D_radial(192, 192).astype(np.float32)

    nufft = get_operator("finufft")(traj, mri_2D.shape, density=False)
    kspace = nufft.op(mri_2D)
    adjoint = nufft.adj_op(kspace)

    fig, axs = plt.subplots(1, 3, figsize=(15, 5))
    axs[0].imshow(abs(mri_2D))
    display_2D_trajectory(traj, subfigure=axs[1])
    axs[2].imshow(abs(adjoint))




.. image-sg:: /generated/autoexamples/GPU/images/sphx_glr_example_density_001.png
   :alt: example density
   :srcset: /generated/autoexamples/GPU/images/sphx_glr_example_density_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (256, 256)
    /volatile/github-ci-mind-inria/action-runner/_work/_tool/Python/3.10.14/x64/lib/python3.10/site-packages/mrinufft/_utils.py:94: UserWarning: Samples will be rescaled to [-pi, pi), assuming they were in [-0.5, 0.5)
      warnings.warn(
    /volatile/github-ci-mind-inria/action-runner/_work/_tool/Python/3.10.14/x64/lib/python3.10/site-packages/finufft/_interfaces.py:329: UserWarning: Argument `data` does not satisfy the following requirement: C. Copying array (this may reduce performance)
      warnings.warn(f"Argument `{name}` does not satisfy the following requirement: {prop}. Copying array (this may reduce performance)")

    <matplotlib.image.AxesImage object at 0x738603c97b50>



.. GENERATED FROM PYTHON SOURCE LINES 51-52

As you can see, the radial sampling pattern as a strong concentration of sampling point in the center, resulting in a  low-frequency biased adjoint reconstruction.

.. GENERATED FROM PYTHON SOURCE LINES 54-62

Geometry based methods
======================

Voronoi
-------

Voronoi Parcellation attribute a weights to each k-space coordinate, inversely
proportional to its voronoi cell area.

.. GENERATED FROM PYTHON SOURCE LINES 62-68

.. code-block:: Python



    # .. warning::
    #    The current implementation of voronoi parcellation is CPU only, and is thus
    #    **very** slow in 3D ( > 1h).








.. GENERATED FROM PYTHON SOURCE LINES 69-84

.. code-block:: Python

    voronoi_weights = get_density("voronoi", traj)

    nufft_voronoi = get_operator("finufft")(
        traj, shape=mri_2D.shape, density=voronoi_weights
    )
    adjoint_voronoi = nufft_voronoi.adj_op(kspace)
    fig, axs = plt.subplots(1, 3, figsize=(15, 5))
    axs[0].imshow(abs(mri_2D))
    axs[0].set_title("Ground Truth")
    axs[1].imshow(abs(adjoint))
    axs[1].set_title("no density compensation")
    axs[2].imshow(abs(adjoint_voronoi))
    axs[2].set_title("Voronoi density compensation")





.. image-sg:: /generated/autoexamples/GPU/images/sphx_glr_example_density_002.png
   :alt: Ground Truth, no density compensation, Voronoi density compensation
   :srcset: /generated/autoexamples/GPU/images/sphx_glr_example_density_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /volatile/github-ci-mind-inria/action-runner/_work/_tool/Python/3.10.14/x64/lib/python3.10/site-packages/mrinufft/_utils.py:94: UserWarning: Samples will be rescaled to [-pi, pi), assuming they were in [-0.5, 0.5)
      warnings.warn(

    Text(0.5, 1.0, 'Voronoi density compensation')



.. GENERATED FROM PYTHON SOURCE LINES 85-90

Cell Counting
-------------

Cell Counting attributes weights based on the number of trajectory point lying in a same k-space nyquist voxel.
This can be viewed as an approximation to the voronoi neth

.. GENERATED FROM PYTHON SOURCE LINES 90-97

.. code-block:: Python


    # .. note::
    #    Cell counting is faster than voronoi (especially in 3D), but is less precise.

    # The size of the niquist voxel can be tweak by using the osf parameter. Typically as the NUFFT (and by default in MRI-NUFFT) is performed at an OSF of 2









.. GENERATED FROM PYTHON SOURCE LINES 98-112

.. code-block:: Python

    cell_count_weights = get_density("cell_count", traj, shape=mri_2D.shape, osf=2.0)

    nufft_cell_count = get_operator("finufft")(
        traj, shape=mri_2D.shape, density=cell_count_weights, upsampfac=2.0
    )
    adjoint_cell_count = nufft_cell_count.adj_op(kspace)
    fig, axs = plt.subplots(1, 3, figsize=(15, 5))
    axs[0].imshow(abs(mri_2D))
    axs[0].set_title("Ground Truth")
    axs[1].imshow(abs(adjoint))
    axs[1].set_title("no density compensation")
    axs[2].imshow(abs(adjoint_cell_count))
    axs[2].set_title("cell_count density compensation")




.. image-sg:: /generated/autoexamples/GPU/images/sphx_glr_example_density_003.png
   :alt: Ground Truth, no density compensation, cell_count density compensation
   :srcset: /generated/autoexamples/GPU/images/sphx_glr_example_density_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /volatile/github-ci-mind-inria/action-runner/_work/_tool/Python/3.10.14/x64/lib/python3.10/site-packages/mrinufft/_utils.py:94: UserWarning: Samples will be rescaled to [-pi, pi), assuming they were in [-0.5, 0.5)
      warnings.warn(

    Text(0.5, 1.0, 'cell_count density compensation')



.. GENERATED FROM PYTHON SOURCE LINES 113-118

Manual Density Estimation
-------------------------

For some analytical trajectory it is also possible to determine the density compensation vector directly.
In radial trajectory for instance, a sample's weight can be determined from its distance to the center.

.. GENERATED FROM PYTHON SOURCE LINES 121-133

.. code-block:: Python

    flat_traj = traj.reshape(-1, 2)
    weights = np.sqrt(np.sum(flat_traj**2, axis=1))
    nufft = get_operator("finufft")(traj, shape=mri_2D.shape, density=weights)
    adjoint_manual = nufft.adj_op(kspace)
    fig, axs = plt.subplots(1, 3, figsize=(15, 5))
    axs[0].imshow(abs(mri_2D))
    axs[0].set_title("Ground Truth")
    axs[1].imshow(abs(adjoint))
    axs[1].set_title("no density compensation")
    axs[2].imshow(abs(adjoint_manual))
    axs[2].set_title("manual density compensation")




.. image-sg:: /generated/autoexamples/GPU/images/sphx_glr_example_density_004.png
   :alt: Ground Truth, no density compensation, manual density compensation
   :srcset: /generated/autoexamples/GPU/images/sphx_glr_example_density_004.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /volatile/github-ci-mind-inria/action-runner/_work/_tool/Python/3.10.14/x64/lib/python3.10/site-packages/mrinufft/_utils.py:94: UserWarning: Samples will be rescaled to [-pi, pi), assuming they were in [-0.5, 0.5)
      warnings.warn(

    Text(0.5, 1.0, 'manual density compensation')



.. GENERATED FROM PYTHON SOURCE LINES 134-146

Operator-based method
=====================

Pipe's Method
-------------
Pipe's method is an iterative scheme, that use the interpolation and spreading kernel operator for computing the density compensation.

.. warning::
   If this method is widely used in the literature, there exists no convergence guarantees for it.

.. note::
   The Pipe method is currently only implemented for gpuNUFFT.

.. GENERATED FROM PYTHON SOURCE LINES 148-161

.. code-block:: Python

    flat_traj = traj.reshape(-1, 2)
    nufft = get_operator("gpunufft")(
        traj, shape=mri_2D.shape, density={"name": "pipe", "osf": 2}
    )
    adjoint_manual = nufft.adj_op(kspace)
    fig, axs = plt.subplots(1, 3, figsize=(15, 5))
    axs[0].imshow(abs(mri_2D))
    axs[0].set_title("Ground Truth")
    axs[1].imshow(abs(adjoint))
    axs[1].set_title("no density compensation")
    axs[2].imshow(abs(adjoint_manual))
    axs[2].set_title("Pipe density compensation")
    print(nufft.density)



.. image-sg:: /generated/autoexamples/GPU/images/sphx_glr_example_density_005.png
   :alt: Ground Truth, no density compensation, Pipe density compensation
   :srcset: /generated/autoexamples/GPU/images/sphx_glr_example_density_005.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [0.00155096 0.00706764 0.01424877 ... 0.56895894 0.46830535 0.60650784]





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 4.165 seconds)


.. _sphx_glr_download_generated_autoexamples_GPU_example_density.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: binder-badge

      .. image:: images/binder_badge_logo.svg
        :target: https://mybinder.org/v2/gh/mind-inria/mri-nufft/gh-pages?urlpath=lab/tree/examples/generated/autoexamples/GPU/example_density.ipynb
        :alt: Launch binder
        :width: 150 px

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: example_density.ipynb <example_density.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: example_density.py <example_density.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: example_density.zip <example_density.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
